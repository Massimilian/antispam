package ru.progwards.java2.lessons;

class Page<K extends Comparable<K>, V> {
    int maxSize; // максимальное количество элементов, которое может быть
    V[] values; // значения, хранимые на странице
    K[] keys; // ключи
    Page<K, V>[] children; // массив страниц, которые являются дочерними для данной страницы
    Page<K, V> parent; // родительская страница

    int findKey(K key) { // вариант для малого количества ключей - поиск перебором
        for (int i = 0; i < maxSize; i++) { // начинаем поиск во внутреннем массиве
            if (key.compareTo(keys[i]) <= 0) // когда условие выполняется и сравниваемый ключ равен (то есть мы нашли) или почти равен (то есть точно такого значения нет, но есть немного больше)
                return i; // возвращаем позицию элемента в массиве
        }
        return maxSize;
    }

    int findKey2(K key) { // вариант поиска для большого количества элементов - поиск дихотомией
        int min = 0;  // устанавливаем минимальное
        int max = maxSize - 1; // и максимальное значение ключа на этой странице
        int i = max;
        while (max > min) {
            i = (max + min) / 2; //разбиваем список (который, не забываем, у нас упорядочен по ключам) пополам
            int cmp = key.compareTo(keys[i]); // сравниваем искомый ключ с текущим
            if (cmp == 0) // если ключи равны -
                return i; // - то мы нашли искомое
            if (cmp < 0) // если результат = -1
                max = i; // то, значит,  результат в правой стороне. Присваиваем максимальному значению середину, уполовинивая список и отбрасывая ненужные элементы
            else // остаётся последний вариант - результат равен 1
                min = i + 1; // значит, искомое слева. Присваиваем минимуму середину, уполовинивая список и отбрасывая ненужную левую сторону; +1 - чтобы алгоритм не зациклился.
        }
        int cmp = key.compareTo(keys[i++]); // если нам попалось число больше правой границы
        if (cmp > 0) // то мы возвращаем того потомка, еоторый больше чем количество ключей
            i++;
        return i;
    }

    void setItem(K key, V value) {

    }

    void addItem(int pos, K key, V value, Page<K, V> child) {

    }

    boolean isFull() {
        return maxSize == keys.length;
    }

    void moveTo(Page<K, V> page, int from) {
        int n = keys.length - from + 1; // вычисляем середину
        System.arraycopy(page.keys, from, keys, 0, n); //заносим в массив keys информацию из старой страницы - от ноля до середины
        System.arraycopy(page.values, from, values, 0, n); // заносим в массив values информацию со старой страницы - от ноля до середины
        System.arraycopy(page.children, from, children, 0, n + 1); //делаем тоже самое с массивом children; не забываем, что потомков на 1 больше чем ключей
    }

    void splitPage() {
        int middle = keys.length / 2 + 1; // находим средний элемент, который мы будем вытаскивать наверх
        Page<K, V> newpage = new Page<>(); // создаём новую страницу
        newpage.moveTo(this, middle + 1); // перемещаем все элементы с середины до конца в новый массив
        parent.addItem(-1, keys[middle], values[middle], newpage); // а в родителя (нового) добавляем серединный элемент. -1 - значит, что точное место ещё надо найти.
        maxSize--;
    }
}
